# ADR Introduce Redis Memory Cache Cluster for Read-Heavy Workloads

## Status
Proposed

## Context
**Business problem**:  
The banking application experiences high latency in handling frequent read operations (product catalog, campaigns, dictionary data) stored in Oracle. This results in high database load, slower response times, and scalability limitations that degrade user experience during peak traffic.

**Constraints**:
- Must maintain financial service reliability and security standards.
- High availability and disaster recovery are mandatory.
- Limited time for major refactors; solution should integrate with current microservice ecosystem.
- Operability by the platform engineering team.

**Assumptions**:
- Cached data is either immutable or tolerates minor staleness.
- Redis is already operated and supported across other banking microservices.
- Cache-aside pattern can be applied without large codebase changes.
- Network encryption, RBAC, and observability tooling are available.

**Out of scope**:
- Write-through or write-behind caching.
- Event-driven invalidation (future phase).
- Schema or data model changes in Oracle.

## Decision
**Chosen option**:  
Implement a **Redis memory cache cluster** as a distributed caching solution for frequently accessed, read-heavy data in the banking application. Redis will be deployed as a **high-availability primary–replica cluster** with **cluster mode enabled** for horizontal scalability. The application will use the **cache-aside pattern** with **Time-To-Live (TTL)**–based invalidation for short-lived data.

**Primary rationale**:
1. Significant reduction in p95/p99 latency and Oracle read load.
2. Operational reuse of existing Redis platform and expertise.
3. Simplified horizontal scalability with built-in sharding and replication.

**Alternative options**
- **Scale Oracle read replicas** – Expensive, increases operational overhead, and limited latency gains compared to in-memory cache.
- **In-process application cache** – Non-distributed, limited capacity, risk of inconsistency across nodes.
- **CDN or edge cache** – Not suitable for personalized or secure banking data paths.

## Consequences
**Positive**
- Expected ≥40% reduction in read latency (p95) within 30 days post-deployment.
- ≥60% reduction in Oracle read QPS for cached entities.
- Improved user experience under high load; supports future event-driven invalidation.

**Negative / Trade-offs**
- Adds operational dependency on Redis infrastructure.
- Risk of stale reads if TTLs not tuned; cache invalidation complexity.
- Increased operational costs for memory capacity and HA configuration.
- Potential vendor lock-in to Redis features.

## References
- [Source: docs/md/ADRs/ADR0/context/business.md, §Context] – Describes latency and database load problems.
- [Source: docs/md/ADRs/ADR0/data/decision.md, §Decision] – Defines Redis cluster setup and invalidation strategy.

---

## Additional Metadata

### KPIs
| KPI Name | Metric Type | Target | Measurement Method |
|-----------|--------------|---------|--------------------|
| Read endpoint p95 latency | Latency (ms) | ≥40% reduction vs baseline | APM histograms segmented by cache hit/miss |
| DB read offload | Throughput (%) | ≥60% reduction in Oracle read QPS | Compare oracle_read_qps before/after |
| Cache hit ratio | Ratio | ≥85% steady-state | Redis hits/(hits+misses) per namespace |
| Endpoint availability | Availability (%) | ≥99.9% (no regression) | SLO burn rate of 5xx/timeouts by cache_result |
| Cost efficiency | Cost ($/1k reads) | ≤ baseline −20% | Redis + DB cost allocation per request volume |

### Risks & Mitigations
| Category | Risk | Mitigation |
|-----------|------|-------------|
| Operational | Cache stampede on expirations | Request coalescing, jittered TTLs, soft TTL with background refresh |
| Security | Sensitive data exposure in cache | TLS, ACLs, encryption at rest, namespace isolation, exclude PII |
| Scalability | Hot partitions/slots | Key hashing tags, pre-splitting, monitoring |
| Consistency | Stale reads | Short TTLs, future event-driven busting |
| Reliability | Node/AZ failures | Multi-AZ replicas, auto-failover, chaos drills |
| Compliance | Regulatory retention rules | Data classification, TTL-aligned retention |
| Migration | App regressions during rollout | Feature flags, shadow reads, gradual rollout |

### Follow-up Plan
| Item | Type |
|------|------|
| Expose cache metrics and tracing attributes | Instrumentation |
| Build dashboards for hit ratio, Redis health, Oracle QPS | Instrumentation |
| Load test to validate KPI deltas | Checkpoint |
| Simulate failover and resharding events | Checkpoint |
| Define TTLs and invalidation policy per entity | Open question |
| Assess client-side caching for ultra-hot keys | Open question |
| Phase 1: TTL + cache-aside; Phase 2: event-based invalidation | Timeline assumption |

### Supersedes / Conflicts
- **Supersedes**: —
- **Conflicts**: —

---

**End of Record**